public > protected > friendly > private  （protect 是保护子类）
一、类的权限：
1、public 任何地方都可以访问。
2、friendly 即默认权限，又称为包访问权限，在同一个包可以访问。
备注：类前面还可以用final修饰(表示类不能被继承,当一个类为final类是，默认是有的方法也是final方法，因此无法覆盖他们)、abstract修饰表示抽象类,这两个跟权限无关

二、内部类的访问权限:(可以理解成方法,类的所有修饰符都可以用)
1、public 任何地方均可访问
2、protected 在同一个包内均可访问;不同的包的子类(即外部类的子类)可以访问,但内部类的构造器必须显式，并且必须为public，不然不可见。
3、friendly(即默认权限) 同一个包内才可以访问
4、private 只有该内部类的外部类本身可以访问

三、类中构造函数的访问权限:(相当于初始化)
1、public 任何地方均可访问
2、protected :在同一包内,可以实例化;不同的包,不能实例化;构造函数可以被继承该类的子类调用(只能在子类构造器super调用);
3、friendly(即默认权限) 同一个包内才可以访问
4、private 该类无法被继承
5、不能是final;

四、类中某成员(方法或属性)的访问权限:
1、public权限，任何类都可以访问；
2、protected权限，继承访问权限，包内其余类和继承该类的子类可以访问。
3、friendly(或称为package)权限，在同一包中的类可以访问；
4、private权限，该类内部的成员(方法、属性、内部类)可以访问







final关键字的含义
final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作final，
你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误

什么是final变量？
凡是对成员变量或者本地变量(在方法中的或者代码块中的变量称为本地变量)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量
final变量是只读的

什么是final方法?
final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，
你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定

什么是final类？
使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类

final关键字的好处
下面总结了一些使用final关键字的好处
final关键字提高了性能。JVM和Java应用都会缓存final变量。
final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
使用final关键字，JVM会对方法、变量及类进行优化。

final类不能被继承，没有子类，final类中的方法默认是final的。
final方法不能被子类的方法覆盖，但可以被继承。
final成员变量表示常量，只能被赋值一次，赋值后值不再改变。
final不能用于修饰构造方法。
 注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。
 
 
在匿名类中所有变量都必须是final变量。
final方法在编译阶段绑定，称为静态绑定(static binding)。
没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，
编译器会报错“final变量(变量名)需要进行初始化”。final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。
final方法不能被重写。
final类不能被继承
你不能够对final变量再次赋值。
本地变量必须在声明时赋值。
final关键字不同于finally关键字，后者用于异常处理。
final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。
接口中声明的所有变量本身是final static的。
final和abstract这两个关键字是反相关的，final类就不可能是abstract的。
将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。
按照Java代码惯例，final变量就是常量，而且通常常量名要大写：
对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容
final关键字可以用于成员变量、本地变量、方法以及类。

要创建不可变类，要实现下面几个步骤：
将类声明为final，所以它不能被继承
将所有的成员声明为私有的，这样就不允许直接访问这些成员
对变量不要提供setter方法
将所有可变的成员声明为final，这样只能对它们赋值一次
通过构造器初始化所有成员，进行深拷贝(deep copy)
在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝


static不依赖与实例，
用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块
因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract
对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，
不可以改变容器变量本身，但可以修改容器中存放的对象。


抽象类和接口

抽象类：
1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。
2）抽象类不能用来创建对象；
3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类

接口：
接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），
而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），
并且接口中所有的方法不能有具体的实现


三.抽象类和接口的区别

1.语法层面上的区别
1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
4）一个类只能继承一个抽象类，而一个类却可以实现多个接口

2.设计层面上的区别
抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。
抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计
而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。
也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动



继承，多态，封装

重载
1、方法名相同，但是里面参数不同。
2、不能通过返回类型来判断是否重载，如果两个方法参数相同，但是返回值不同，这样不是重载,且报错。

重写（覆盖和隐藏）
只有非静态方法才能覆蓋,其他都是隐藏.

隐藏指的是子类把父类的属性或者方法隐藏了，即将子类强制转换成父类后，调用的还是父类的属性和方法，
而覆盖则指的是父类引用指向了子类对象，调用的时候会调用子类的具体方法(只有非静态方法才能覆蓋)。
(1) 变量只能被隐藏(包括静态和非静态)，不能被覆盖(所以无需关心子类和父类里面的任何变量类型以及和常量（常量跟实例无关）)。
(2)常量无需考虑。
(3) 不能重写父类中的最终方法(final)；
(4) 静态方法(static)只能被隐藏，不能被覆盖；
(5) 不能用子类的静态方法隐藏父类中的非静态方法，否则编译会报错；
(6) 不能用子类的非静态方法覆盖父类的静态方法，否则编译会报错；
(7) 非静态方法可以被覆盖；
(8) 抽象方法必须在具体类中被覆盖；
(9)重写的方法和被重写的方法必须具有相同方法名称、参数列表和返回类型。
(10)重写方法不能使用比被重写的方法更严格的访问权限 
(11)重写如果父类抛出异常,子类必须抛出 父类异常的子类异常或者非检查异常或者不拋出异常。(即父类不抛出异常，子类也不能抛出异常)

检查型异常（CheckedException）与非检查型异常（UncheckedException）

检查型异常：
在Java中所有不是RuntimeException派生的Exception都是检查型异常。
当函数中存在抛出检查型异常的操作时该函数的函数声明中必须包含throws语句。
调用改函数的函数也必须对该异常进行处理，如不进行处理则必须在调用函数上声明throws语句，如IOException，SQLException ,FileNotFoundException

非检查型异常：
在Java中所有RuntimeException的派生类都是非检查型异常，
与检查型异常相对抛出非检查型异常可以不在函数声明中添加throws语句，调用函数上也不需要强制处理。
常见的NullPointException，ClassCastException、ArrayIndexsOutOfBoundsException,ArithmeticException是常见的非检查型异常。
非检查型异常 可以不使用try...catch进行处理，但是如果有异常产生，则异常将由JVM进行处理。
对于RuntimeException的子类最好也使用异常处理机制。虽然RuntimeException的异常可以不使用try...catch进行处理，
但是如果一旦发生异常，则肯定会导致程序中断执行，所以，为了保证程序再出错后依然可以执行，在开发代码时最好使用try...catch的异常处理机制进行处理



内部类：
成员内部类:
(1)成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）
(2)不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要内部类访问外部类的同名成员，需要以下面的形式进行访问：
外部类.this.成员变量
外部类.this.成员方法
(3)虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。
在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问
(4)只有内部类声明为static时，内部类方法才能可以声明为static
(5)访问方式 外部类引用.new 内部类();

局部内部类:
局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。

匿名内部类:

静态内部类:
静态内部类有特殊的地方吗？
静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。
另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译class文件看一下就知道了，是没有Outter this&0引用的

1.为什么成员内部类可以无条件访问外部类的成员？
虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，
所以成员内部类中的Outter this&0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。
从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&0引用进行初始化赋值，
也就无法创建成员内部类的对象了。

2.匿名内部类只能访问局部final变量？
匿名内部类的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。
这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。
也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。
如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。
既然在run方法中访问的变量a和test方法中的变量a不是同一个变量，当在run方法中改变变量a的值的话，会出现什么情况？
对，会造成数据不一致性 ，这样就达不到原本的意图和要求。为了解决这个问题，java编译器就限定必须将变量a限制为final变量，不允许对变量a进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。
到这里，想必大家应该清楚为何 方法中的局部变量和形参都必须用final进行限定了。


为什么在Java中需要内部类？总结一下主要有以下四点：

1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，
4.方便编写线程代码
2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。封装性。
3.方便编写事件驱动程序
个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。

创建静态内部类对象的一般形式为：  外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()

创建成员内部类对象的一般形式为：  外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()




